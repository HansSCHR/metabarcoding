---
title: "Metabarcoding"
author: "Hans Schrieke"
date: "26/07/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
library(dada2); packageVersion("dada2")


plot_folder <- function(path, name){
  folder <- sprintf("%s", name)
  dir.create(folder)
  path2 <- getwd()
  path3 <- file.path(path2, folder)
  setwd(path3)
  .off()
}


dada2 <- function(path, run){

  if (run == "run1"){
    path <- file.path(path, "run1")
  }
  if (run == "run2_new"){
    path <- file.path(path, "run2_new")
  }
  if (run == "run3_new"){
    path <- file.path(path, "run3_new")
  }
  if (run == "run4_new"){
    path <- file.path(path, "run4_new")
  }
  
  setwd(path)
  print(path)

  # Store forward and reverse reads 
  forward <- sort(list.files(path, pattern="_R1_001.fastq.gz", full.names = TRUE))
  fwd <<- forward
  reverse <- sort(list.files(path, pattern="_R2_001.fastq.gz", full.names = TRUE))
  rvs <<- reverse
  
  # Store sample names 
  sample.names <- sapply(strsplit(basename(forward), "_"), `[`, 1) 
  
  



  filtForward <- file.path(path, "filtered", paste0(sample.names, "_F_filt.fastq.gz"))
  filtReverse <- file.path(path, "filtered", paste0(sample.names, "_R_filt.fastq.gz"))
  
  out <- filterAndTrim(forward, filtForward, reverse, filtReverse, truncLen=c(245,235),
                       maxN=0, maxEE=c(2,4), truncQ=2, rm.phix=TRUE,
                       compress=TRUE, multithread=TRUE)
  head(out)
  print("filter and trim ok")


  errForward <- learnErrors(filtForward, multithread=TRUE)
  errFwd <<- errForward
  errReverse <- learnErrors(filtReverse, multithread=TRUE)
  errRvs <<- errReverse



  # Dereplication
  derepForward <- derepFastq(filtForward, verbose=TRUE)
  derepReverse <- derepFastq(filtReverse, verbose=TRUE)
  # Name the derep-class objects by the sample names
  names(derepForward) <- sample.names
  names(derepReverse) <- sample.names



  dadaForward <- dada(derepForward, err=errForward, multithread=TRUE)
  dadaReverse <- dada(derepReverse, err=errReverse, multithread=TRUE)



  mergers <- mergePairs(dadaForward, derepForward, dadaReverse, derepReverse, verbose=TRUE)
  head(mergers[[1]])
  print("Reads merged.")



  seqtab <- makeSequenceTable(mergers)
  
  # Remove chimeras
  seqtab.nochim <- removeBimeraDenovo(seqtab, method="consensus", multithread=TRUE, verbose=TRUE)
  dim(seqtab.nochim)
  sum(seqtab.nochim)/sum(seqtab)
  
  # csv
  write.table(t(seqtab),  "seqtab1.csv", sep=";", dec=",")
  write.table(t(seqtab.nochim),  "seqtabnochim1.csv", sep=";", dec=",")
  saveRDS(seqtab.nochim, file="seqtab1.rds")
  seqtabnochim1 <<- seqtab.nochim
  print("Seqtable done.")



  getN <- function(x) sum(getUniques(x))
  track <- cbind(out, sapply(dadaForward, getN), sapply(dadaReverse, getN), sapply(mergers, getN), rowSums(seqtab.nochim))
  
  colnames(track) <- c("input", "filtered", "denoisedF", "denoisedR", "merged", "nonchim")
  rownames(track) <- sample.names
  head(track)
  
  # csv
  write.table(track,"stats1.csv",sep=";",dec=",") 
  saveRDS(track, file="stats1.rds")
  stats1 <<- track
  print("Stats done.")



  taxa <- assignTaxonomy(seqtab.nochim, file.path(path, "silva_nr_v132_train_set.fa.gz"), multithread=TRUE, minBoot=80)
  taxa <- addSpecies(taxa, file.path(path, "silva_species_assignment_v132.fa.gz"))
  
  #taxa.print <- taxa # Removing sequence rownames for display only
  #rownames(taxa.print) <- NULL
  #head(taxa.print)
  write.table(taxa,"taxa1.csv",sep=";",dec=",")
  saveRDS(taxa, file="taxa1.rds")
  taxa1 <<- taxa
  print ("Taxonomy done.")
  
  # Phylogenetic tree (with decipher and phangorn packages)
  #library(DECIPHER)
  #library(phangorn)
  
  #seqs <- getSequences(seqtab.nochim)
  #names(seqs) <- seqs
  #alignment <- AlignSeqs(DNAStringSet(seqs), anchor=NA)
  
  #phang.align <- phyDat(as(alignment, "matrix"), type="DNA")
  #dm <- dist.ml(phang.align)
  #treeNJ <- NJ(dm)
  #fit = pml(treeNJ, data=phang.align)
  
  #fitGTR <- update(fit, k=4, inv=0.2)
  #fitGTR <- optim.pml(fitGTR, model="GTR", optInv=TRUE, optGamma=TRUE,
                      #rearrangement = "stochastic", control = pml.control(trace = 0))
  #detach("package:phangorn", unload=TRUE)
  
  #write.table(fitGTR$tree, "phylotree.csv", sep=";", dec=",")
  #print("Job done")

}

path = "D:/stage/data/rmarkdown_folder"
setwd(path)

dada2(path, "run1")

setwd(path)

dada2(path, "run2")

setwd(path)

dada2(path, "run3")



```



## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.
